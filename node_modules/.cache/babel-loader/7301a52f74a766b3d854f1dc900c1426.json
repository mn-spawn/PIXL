{"ast":null,"code":"const Mode = require('./mode');\n/**\r\n * Array of characters available in alphanumeric mode\r\n *\r\n * As per QR Code specification, to each character\r\n * is assigned a value from 0 to 44 which in this case coincides\r\n * with the array index\r\n *\r\n * @type {Array}\r\n */\n\n\nconst ALPHA_NUM_CHARS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', ' ', '$', '%', '*', '+', '-', '.', '/', ':'];\n\nfunction AlphanumericData(data) {\n  this.mode = Mode.ALPHANUMERIC;\n  this.data = data;\n}\n\nAlphanumericData.getBitsLength = function getBitsLength(length) {\n  return 11 * Math.floor(length / 2) + 6 * (length % 2);\n};\n\nAlphanumericData.prototype.getLength = function getLength() {\n  return this.data.length;\n};\n\nAlphanumericData.prototype.getBitsLength = function getBitsLength() {\n  return AlphanumericData.getBitsLength(this.data.length);\n};\n\nAlphanumericData.prototype.write = function write(bitBuffer) {\n  let i; // Input data characters are divided into groups of two characters\n  // and encoded as 11-bit binary codes.\n\n  for (i = 0; i + 2 <= this.data.length; i += 2) {\n    // The character value of the first character is multiplied by 45\n    let value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45; // The character value of the second digit is added to the product\n\n    value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1]); // The sum is then stored as 11-bit binary number\n\n    bitBuffer.put(value, 11);\n  } // If the number of input data characters is not a multiple of two,\n  // the character value of the final character is encoded as a 6-bit binary number.\n\n\n  if (this.data.length % 2) {\n    bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6);\n  }\n};\n\nmodule.exports = AlphanumericData;","map":{"version":3,"names":["Mode","require","ALPHA_NUM_CHARS","AlphanumericData","data","mode","ALPHANUMERIC","getBitsLength","length","Math","floor","prototype","getLength","write","bitBuffer","i","value","indexOf","put","module","exports"],"sources":["C:/Users/Maddi/Documents/GitHub/PIXL/node_modules/qrcode/lib/core/alphanumeric-data.js"],"sourcesContent":["const Mode = require('./mode')\r\n\r\n/**\r\n * Array of characters available in alphanumeric mode\r\n *\r\n * As per QR Code specification, to each character\r\n * is assigned a value from 0 to 44 which in this case coincides\r\n * with the array index\r\n *\r\n * @type {Array}\r\n */\r\nconst ALPHA_NUM_CHARS = [\r\n  '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\r\n  'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\r\n  'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\r\n  ' ', '$', '%', '*', '+', '-', '.', '/', ':'\r\n]\r\n\r\nfunction AlphanumericData (data) {\r\n  this.mode = Mode.ALPHANUMERIC\r\n  this.data = data\r\n}\r\n\r\nAlphanumericData.getBitsLength = function getBitsLength (length) {\r\n  return 11 * Math.floor(length / 2) + 6 * (length % 2)\r\n}\r\n\r\nAlphanumericData.prototype.getLength = function getLength () {\r\n  return this.data.length\r\n}\r\n\r\nAlphanumericData.prototype.getBitsLength = function getBitsLength () {\r\n  return AlphanumericData.getBitsLength(this.data.length)\r\n}\r\n\r\nAlphanumericData.prototype.write = function write (bitBuffer) {\r\n  let i\r\n\r\n  // Input data characters are divided into groups of two characters\r\n  // and encoded as 11-bit binary codes.\r\n  for (i = 0; i + 2 <= this.data.length; i += 2) {\r\n    // The character value of the first character is multiplied by 45\r\n    let value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45\r\n\r\n    // The character value of the second digit is added to the product\r\n    value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1])\r\n\r\n    // The sum is then stored as 11-bit binary number\r\n    bitBuffer.put(value, 11)\r\n  }\r\n\r\n  // If the number of input data characters is not a multiple of two,\r\n  // the character value of the final character is encoded as a 6-bit binary number.\r\n  if (this.data.length % 2) {\r\n    bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6)\r\n  }\r\n}\r\n\r\nmodule.exports = AlphanumericData\r\n"],"mappings":"AAAA,MAAMA,IAAI,GAAGC,OAAO,CAAC,QAAD,CAApB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,eAAe,GAAG,CACtB,GADsB,EACjB,GADiB,EACZ,GADY,EACP,GADO,EACF,GADE,EACG,GADH,EACQ,GADR,EACa,GADb,EACkB,GADlB,EACuB,GADvB,EAEtB,GAFsB,EAEjB,GAFiB,EAEZ,GAFY,EAEP,GAFO,EAEF,GAFE,EAEG,GAFH,EAEQ,GAFR,EAEa,GAFb,EAEkB,GAFlB,EAEuB,GAFvB,EAE4B,GAF5B,EAEiC,GAFjC,EAEsC,GAFtC,EAGtB,GAHsB,EAGjB,GAHiB,EAGZ,GAHY,EAGP,GAHO,EAGF,GAHE,EAGG,GAHH,EAGQ,GAHR,EAGa,GAHb,EAGkB,GAHlB,EAGuB,GAHvB,EAG4B,GAH5B,EAGiC,GAHjC,EAGsC,GAHtC,EAItB,GAJsB,EAIjB,GAJiB,EAIZ,GAJY,EAIP,GAJO,EAIF,GAJE,EAIG,GAJH,EAIQ,GAJR,EAIa,GAJb,EAIkB,GAJlB,CAAxB;;AAOA,SAASC,gBAAT,CAA2BC,IAA3B,EAAiC;EAC/B,KAAKC,IAAL,GAAYL,IAAI,CAACM,YAAjB;EACA,KAAKF,IAAL,GAAYA,IAAZ;AACD;;AAEDD,gBAAgB,CAACI,aAAjB,GAAiC,SAASA,aAAT,CAAwBC,MAAxB,EAAgC;EAC/D,OAAO,KAAKC,IAAI,CAACC,KAAL,CAAWF,MAAM,GAAG,CAApB,CAAL,GAA8B,KAAKA,MAAM,GAAG,CAAd,CAArC;AACD,CAFD;;AAIAL,gBAAgB,CAACQ,SAAjB,CAA2BC,SAA3B,GAAuC,SAASA,SAAT,GAAsB;EAC3D,OAAO,KAAKR,IAAL,CAAUI,MAAjB;AACD,CAFD;;AAIAL,gBAAgB,CAACQ,SAAjB,CAA2BJ,aAA3B,GAA2C,SAASA,aAAT,GAA0B;EACnE,OAAOJ,gBAAgB,CAACI,aAAjB,CAA+B,KAAKH,IAAL,CAAUI,MAAzC,CAAP;AACD,CAFD;;AAIAL,gBAAgB,CAACQ,SAAjB,CAA2BE,KAA3B,GAAmC,SAASA,KAAT,CAAgBC,SAAhB,EAA2B;EAC5D,IAAIC,CAAJ,CAD4D,CAG5D;EACA;;EACA,KAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG,CAAJ,IAAS,KAAKX,IAAL,CAAUI,MAA/B,EAAuCO,CAAC,IAAI,CAA5C,EAA+C;IAC7C;IACA,IAAIC,KAAK,GAAGd,eAAe,CAACe,OAAhB,CAAwB,KAAKb,IAAL,CAAUW,CAAV,CAAxB,IAAwC,EAApD,CAF6C,CAI7C;;IACAC,KAAK,IAAId,eAAe,CAACe,OAAhB,CAAwB,KAAKb,IAAL,CAAUW,CAAC,GAAG,CAAd,CAAxB,CAAT,CAL6C,CAO7C;;IACAD,SAAS,CAACI,GAAV,CAAcF,KAAd,EAAqB,EAArB;EACD,CAd2D,CAgB5D;EACA;;;EACA,IAAI,KAAKZ,IAAL,CAAUI,MAAV,GAAmB,CAAvB,EAA0B;IACxBM,SAAS,CAACI,GAAV,CAAchB,eAAe,CAACe,OAAhB,CAAwB,KAAKb,IAAL,CAAUW,CAAV,CAAxB,CAAd,EAAqD,CAArD;EACD;AACF,CArBD;;AAuBAI,MAAM,CAACC,OAAP,GAAiBjB,gBAAjB"},"metadata":{},"sourceType":"script"}